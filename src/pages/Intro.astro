---
---

<div id="intro" class="drawable relative px-12 flex flex-col items-center justify-center xl:flex-row xl:justify-start xl:px-0">
    <div class="xl:ml-24">
        <div class="flex flex-col gap-6 ml-6 text-5xl font-bold">
            <h1 class="text-orange-500">Hello, I'm Ian.</h1>
            <p>I like to write code.</p>
        </div>
        <div class="relative">
            <p id="anim-p" class="my-6 p-6 text-xl xl:w-1/3">
                I especially like to write code I can read again, or that someone else can read. This is an interpretation of "clean code", and it means something different to every developer.<br/><br/>To me, it means maintenance above all else. Code that can be read (preferably once) and understood, both by me when I inevitably forget about it, and as a bonus anyone else who happens to read it.
            </p>
            <button class="ml-6 py-3 px-4 my-4 rounded-md bg-orange-400 text-white cursor-pointer">Get in touch</button>
        </div>
     </div>
    <svg class="absolute h-full w-full overflow-visible">
        <defs>
          <linearGradient id="gradient" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" style={{ stopColor: "#EA580C", stopOpacity: 1 }}/>
            <stop offset="100%" style={{ stopColor: "#FDBA74", stopOpacity: 1 }}/>
          </linearGradient>
        </defs>
        <path
          id="line1-path"
          fill="none"
          stroke="url(#gradient)"
          stroke-width="4"></path>
    </svg>
    <svg class="absolute h-full w-full overflow-visible">
        <defs>
          <linearGradient id="gradient2" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" style={{ stopColor: "#E2955F", stopOpacity: 1 }}/>
            <stop offset="100%" style={{ stopColor: "#643617", stopOpacity: 1 }}/>
          </linearGradient>
        </defs>
        <path
          id="line2-path"
          fill="none"
          stroke="url(#gradient2)"
          stroke-width="4"></path>
    </svg>
</div>

<script>
    function animateLines() {
        const line1Path = document.querySelector("#line1-path") as SVGPathElement

        line1Path.setAttribute("d",
            `M0,${window.innerHeight - window.innerHeight/4} 
            h${window.innerWidth*2/3}
            v${-window.innerHeight/4}
            h${window.innerWidth/3}`)

        const pathLength = line1Path.getTotalLength()
        line1Path.style.strokeDasharray = pathLength.toString()
        line1Path.style.strokeDashoffset = pathLength.toString()

        const line2Path = document.querySelector("#line2-path") as SVGPathElement
        line2Path.setAttribute("d",
            `M0,${window.innerHeight - window.innerHeight/5} 
            h${window.innerWidth/10}
            v${-window.innerHeight/6}
            h${window.innerWidth*8/10}
            v${window.innerWidth/8}
            h${window.innerWidth/10}`)
        
        const pathLength2 = line2Path.getTotalLength()
        line2Path.style.strokeDasharray = pathLength2.toString()
        line2Path.style.strokeDashoffset = pathLength2.toString()

        setTimeout(() => {
            line1Path.style.transition = 'stroke-dashoffset 1.25s ease-out'
            line1Path.style.strokeDashoffset = '0'
        }, 1000)

        setTimeout(() => {
            line2Path.style.transition = 'stroke-dashoffset 0.75s ease-out'
            line2Path.style.strokeDashoffset = '0'
        }, 1000)

    }

    window.addEventListener("DOMContentLoaded", animateLines)
    window.addEventListener("resize", animateLines)
</script>
